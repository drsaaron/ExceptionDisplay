/*
 * WrappingLabel.java
 *
 * Created on April 19, 2007, 1:38 PM
 */

package com.blazartech.util.gui.exception;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.font.FontRenderContext;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import javax.swing.JComponent;

/**
 * A label-like component that supports wrapping of the text.  Code taken from 
 * http://forum.java.sun.com/thread.jspa?threadID=459705&messageID=2104021
 *
 * @author Dr. Scott E. Aaron
 * @version $Id: WrappingLabel.java 21 2015-04-23 19:41:38Z aar1069 $
 */

/* $Log: WrappingLabel.java,v $
/* Revision 1.1  2007/07/17 19:08:20  AAR1069
/* Initial revision
/*
 *******************************************************************************/

class WrappingLabel extends JComponent {
    
    private final Insets margin = new Insets(5,5,5,5);
    private final FontRenderContext frc = new FontRenderContext(null, false, false);
    
    /** Creates new form BeanForm */
    public WrappingLabel() {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        
    }
    // </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
    
    /**
     * Holds value of property text.
     */
    private String text;
    
    /**
     * Getter for property text.
     * @return Value of property text.
     */
    public String getText() {
        return this.text;
    }
    
    /**
     * Setter for property text.
     * @param text New value of property text.
     */
    public void setText(String text) {
        String oldText = this.text;
        this.text = text;
        firePropertyChange("text", oldText, text);
    }
    
    /**
     * Holds value of property maxWidth.
     */
    private int maxWidth = Integer.MAX_VALUE;
    
    /**
     * Getter for property maxWidth.
     * @return Value of property maxWidth.
     */
    public int getMaxWidth() {
        return this.maxWidth;
    }
    
    /**
     * Setter for property maxWidth.
     * @param maxWidth New value of property maxWidth.
     */
    public void setMaxWidth(int maxWidth) {
        if (maxWidth <= 0) { throw new IllegalArgumentException("maxWidth must be > 0"); }
        int oldMaxWidth = this.maxWidth;
        this.maxWidth = maxWidth;
        firePropertyChange("maxWidth", oldMaxWidth, maxWidth);
    }
    
    /**
     * Holds value of property justified.
     */
    private boolean justified;
    
    /**
     * Getter for property justified.
     * @return Value of property justified.
     */
    public boolean isJustified() {
        return this.justified;
    }
    
    /**
     * Setter for property justified.
     * @param justified New value of property justified.
     */
    public void setJustified(boolean justified) {
        boolean oldJustified = this.justified;
        this.justified = justified;
        firePropertyChange("justified", oldJustified, justified);
    }
    
    /**
     * If the <code>preferredSize</code> has been set to a
     * non-<code>null</code> value just returns it.
     * If the UI delegate's <code>getPreferredSize</code>
     * method returns a non <code>null</code> value then return that;
     * otherwise defer to the component's layout manager.
     *
     *
     * @return the value of the <code>preferredSize</code> property
     * @see #setPreferredSize
     * @see ComponentUI
     */
    @Override
    public Dimension getPreferredSize() {
        return paintOrGetSize(null, getMaxWidth());
    }
    
    /**
     * If the minimum size has been set to a non-<code>null</code> value
     * just returns it.  If the UI delegate's <code>getMinimumSize</code>
     * method returns a non-<code>null</code> value then return that; otherwise
     * defer to the component's layout manager.
     *
     *
     * @return the value of the <code>minimumSize</code> property
     * @see #setMinimumSize
     * @see ComponentUI
     */
    @Override
    public Dimension getMinimumSize() {
        return getPreferredSize();
    }
    
    /**
     * Calls the UI delegate's paint method, if the UI delegate
     * is non-<code>null</code>.  We pass the delegate a copy of the
     * <code>Graphics</code> object to protect the rest of the
     * paint code from irrevocable changes
     * (for example, <code>Graphics.translate</code>).
     * <p>
     * If you override this in a subclass you should not make permanent
     * changes to the passed in <code>Graphics</code>. For example, you
     * should not alter the clip <code>Rectangle</code> or modify the
     * transform. If you need to do these operations you may find it
     * easier to create a new <code>Graphics</code> from the passed in
     * <code>Graphics</code> and manipulate it. Further, if you do not
     * invoker super's implementation you must honor the opaque property,
     * that is
     * if this component is opaque, you must completely fill in the background
     * in a non-opaque color. If you do not honor the opaque property you
     * will likely see visual artifacts.
     * <p>
     * The passed in <code>Graphics</code> object might
     * have a transform other than the identify transform
     * installed on it.  In this case, you might get
     * unexpected results if you cumulatively apply
     * another transform.
     *
     *
     * @param g the <code>Graphics</code> object to protect
     * @see #paint
     * @see ComponentUI
     */
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        paintOrGetSize((Graphics2D)g, getWidth());
    }
    
    
    private Dimension paintOrGetSize(Graphics2D g, int width) {
        Insets insets = getInsets();
        width -= insets.left + insets.right + margin.left + margin.right;
        float w = insets.left + insets.right + margin.left + margin.right;
        float x = insets.left + margin.left, y=insets.top + margin.top;
        
        if (width > 0 && text != null && text.length() > 0) {
            AttributedString as = new AttributedString(getText());
            as.addAttribute(TextAttribute.FONT, getFont());
            AttributedCharacterIterator aci = as.getIterator();
            LineBreakMeasurer lbm = new LineBreakMeasurer(aci, frc);
            float max = 0;
            while (lbm.getPosition() < aci.getEndIndex()) {
                TextLayout textLayout = lbm.nextLayout(width);
                if (g != null && isJustified() && textLayout.getVisibleAdvance() > 0.80 * width)
                    textLayout = textLayout.getJustifiedLayout(width);
                if (g != null)
                    textLayout.draw(g, x, y + textLayout.getAscent());
                y += textLayout.getDescent() + textLayout.getLeading() + textLayout.getAscent();
                max = Math.max(max, textLayout.getVisibleAdvance());
            }
            w += max;
        }
        
        return new Dimension((int)Math.ceil(w), (int)Math.ceil(y) + insets.bottom + margin.bottom);    
    }
}
